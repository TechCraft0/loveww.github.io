[{"title":"Lidar 地面分割算法对比及实现","url":"/2025/09/22/Lidar-%E5%9C%B0%E9%9D%A2%E5%88%86%E5%89%B2%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94%E5%8F%8A%E5%AE%9E%E7%8E%B0/","content":""},{"title":"Lidar 地面分割算法综述","url":"/2025/09/22/Lidar-%E5%9C%B0%E9%9D%A2%E5%88%86%E5%89%B2%E7%AE%97%E6%B3%95%E7%BB%BC%E8%BF%B0/","content":""},{"title":"Lidar重复式扫描和非重复式扫描区别及主要特性","url":"/2025/09/22/Lidar%E9%87%8D%E5%A4%8D%E5%BC%8F%E6%89%AB%E6%8F%8F%E5%92%8C%E9%9D%9E%E9%87%8D%E5%A4%8D%E5%BC%8F%E6%89%AB%E6%8F%8F%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7/","content":"自21世纪初激光雷达在DARPA无人车大赛上首次亮相以来，在过去十余年的自动驾驶行业发展浪潮中，被主流认可的激光雷达形态长期属于机械式激光雷达。非重复是扫描是livox &#x3D;&#x3D;览沃&#x3D;&#x3D;在2020年初的CES展会上，Livox面向混合固态时代打造的浩界系列首款激光雷达Horizon横空出世，其7000元级的售价除了给市场提供一剂“激光雷达用得起、买得到”的强心针以外，也给自动驾驶感知算法领域带来了一个新事物：基于旋转棱镜扫描模式下的非重复点云形态。那么下文将会对以重复式扫描的代表机械式激光雷达和非重复式扫描的代表的Livox Mid360激光雷达进行对比分析。\n1. 什么是重复式扫描和非重复式扫描？&gt; \n\n参考- https://zhuanlan.zhihu.com/p/551589651\n\n","categories":["Lidar"],"tags":["Lidar","重复式扫描","非重复式扫描"]},{"title":"YOLO系列-《YOLOv1：将检测视为回归的极简美学》","url":"/2026/01/03/YOLO%E7%B3%BB%E5%88%97-YOLOv1%EF%BC%9A%E5%B0%86%E6%A3%80%E6%B5%8B%E8%A7%86%E4%B8%BA%E5%9B%9E%E5%BD%92%E7%9A%84%E6%9E%81%E7%AE%80%E7%BE%8E%E5%AD%A6/","content":"前言","categories":["YOLO系列"],"tags":["YOLOv1","数据增强"]},{"title":"Hello World","url":"/2025/09/20/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"stm32矩阵按键原理及程序","url":"/2025/09/20/stm32%E7%9F%A9%E9%98%B5%E6%8C%89%E9%94%AE%E5%8E%9F%E7%90%86%E5%8F%8A%E7%A8%8B%E5%BA%8F/","content":"\n矩阵键盘原理矩阵键盘是一种高效检测多个按键的方法，通过行列交替扫描来节省GPIO口资源。在STM32中，只需合理配置GPIO输入输出模式，就能实现4×4矩阵键盘的检测逻辑。\n初始化设置列初始化：将所有列（PF0, PF1, PF2, PF3）设置为上拉输入模式。\n行初始化：将所有行（PF4, PF5, PF6, PF7）设置为推挽输出模式。\n\n扫描过程选择列：从第一列开始，依次选择每一列进行扫描。\n输出低电平：当选择某一列时，将该列设为低电平，其他列为高电平。\n检测行状态：检测所有行的状态，如果某一行检测到低电平，则表示该行与当前列交叉处的按键被按下。\n\n示例说明假设我们正在扫描第一列（PF0），此时输出低电平，并检测行的状态：\n如果F7检测到低电平（即PF7为低电平），则表示S1按键被按下。\n如果F6检测到低电平（即PF6为低电平），则表示S2按键被按下。\n以此类推，可以检测到第一行的所有按键值（S1, S2, S3, S4）。\n\n同理，通过扫描其他列，可以检测到整个矩阵键盘上的所有按键值（共16个按键）。\n程序下载完整示例程序（含 STM32 矩阵键盘扫描代码）：  \n\n📥 链接：点击下载  \n🔑 提取码：r3hs\n\n总结矩阵键盘通过行列交替扫描，可以高效检测多个按键，节省IO口资源。在STM32中，只需合理配置GPIO输入输出模式，就能实现4×4矩阵键盘的检测逻辑。\n🚀 下一步可以尝试：  \n\n加入按键消抖处理：消除按键按下时产生的抖动现象，提高按键检测的准确性。\n支持多键同时按下：实现对多个按键同时按下的检测功能，扩展键盘的应用场景。\n与中断或RTOS配合使用：结合中断或实时操作系统（RTOS），进一步优化键盘扫描的效率和响应速度。\n\n","categories":["stm32"]},{"title":"transformer 手搓过程及思考","url":"/2025/09/22/transformer-%E6%89%8B%E6%90%93%E8%BF%87%E7%A8%8B%E5%8F%8A%E6%80%9D%E8%80%83/","content":"transformer 手搓过程及思考1. 前言最近在研究transformer，发现网上很多教程都是直接给出代码，没有详细讲解，导致自己看了很久还是一头雾水，因此决定自己动手实现一个transformer，加深对transformer的理解。\n2. transformer 基本结构transformer的基本结构如下：\n\ntransformer由encoder和decoder两部分组成，encoder和decoder都是由多个相同的层堆叠而成，每个层由多头自注意力机制和前馈神经网络组成。\n参考\nAttention Is All You Need\nhttps://github.com/harvardnlp/annotated-transformer\n\n","categories":["LLM"],"tags":["LLM","Transformer","手搓"]},{"title":"大模型微调方法调研","url":"/2025/09/21/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BE%AE%E8%B0%83%E6%96%B9%E6%B3%95%E8%B0%83%E7%A0%94/","content":"大模型微调方法调研\n2019年谷歌的研究人员首次在论文《Parameter-Efficient Transfer Learning for NLP》提出针对 BERT 的 PEFT微调方式，拉开了 PEFT 研究的序幕。他们指出，在面对特定的下游任务时，如果进行 Full-Fintuning（即预训练模型中的所有参数都进行微调），太过低效；而如果采用固定预训练模型的某些层，只微调接近下游任务的那几层参数，又难以达到较好的效果。\n\n参考链接\nhttps://blog.csdn.net/acelit/article/details/137838266\n\n","categories":["综述"],"tags":["LLM","SFT","调研"]},{"title":"我的第一篇 Butterfly 博客","url":"/2025/09/20/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87-Butterfly-%E5%8D%9A%E5%AE%A2/","content":"1. 环境准备在开始之前，需要先准备好环境：\n\n安装 Node.js（推荐 LTS 版本）\n安装 Git\n\n安装完成后，检查版本：\nnode -vnpm -vgit --version````## 2. 安装 Hexo在你想存放博客的文件夹中执行：```bashnpm install -g hexo-clihexo init myblogcd myblognpm install\n\n然后启动本地服务：\nhexo s\n\n浏览器访问 http://localhost:4000，就能看到默认页面。\n3. 更换 Butterfly 主题进入博客目录 myblog，下载 Butterfly 主题：\ngit clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly\n\n修改 _config.yml 文件，把主题改成：\ntheme: butterfly\n\n安装必要依赖：\nnpm install hexo-renderer-pug hexo-renderer-stylus --save\n\n重启服务后，你就能看到漂亮的 Butterfly 界面啦。\n4. 写文章使用命令新建文章：\nhexo new post &quot;我的第一篇文章&quot;\n\n文章会生成在 source/_posts/ 目录下，你可以用 Markdown 来写内容。\n5. 部署到 GitHub Pages\n在 GitHub 创建一个仓库，命名为：你的用户名.github.io\n安装部署插件：\n\nnpm install hexo-deployer-git --save\n\n\n编辑 _config.yml，加入部署配置：\n\ndeploy:  type: git  repo: https://github.com/你的用户名/你的用户名.github.io.git  branch: main\n\n\n执行命令部署：\n\nhexo cleanhexo ghexo d\n\n部署完成后，访问 https://你的用户名.github.io 就能看到你的博客啦！\n6. 常用命令\nhexo new post &quot;文章标题&quot; ：新建文章\nhexo s ：启动本地服务器\nhexo g ：生成静态文件\nhexo d ：部署到远程\n\n总结从零开始搭建博客其实并不难，主要流程就是：\n👉 安装 Hexo → 使用 Butterfly 主题 → 写文章 → 部署上线\n之后你还可以：\n\n美化主题（添加背景、切换字体、增加特效）\n配置评论系统（Waline、Gitalk、Twikoo 等）\n添加站点统计（不蒜子、百度统计、Google Analytics）\n\n未来再继续折腾！🚀\n\n\n","categories":["教程"],"tags":["Hexo","Butterfly","初学"]},{"title":"寻根溯源：我的 YOLO 全系列深度解析之旅 (开篇)","url":"/2026/01/03/%E5%AF%BB%E6%A0%B9%E6%BA%AF%E6%BA%90%EF%BC%9A%E6%88%91%E7%9A%84-YOLO-%E5%85%A8%E7%B3%BB%E5%88%97%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%E4%B9%8B%E6%97%85-%E5%BC%80%E7%AF%87/","content":"寻根溯源：我的 YOLO 全系列深度解析之旅 (开篇)0. 前言：为什么要写这个系列？在计算机视觉（CV）的江湖里，YOLO (You Only Look Once) 是一个绕不开的名字。从 2015 年 Redmon 提出 v1 版本至今，YOLO 系列已经走过了近十个年头，演进到了如今的 v11。\n作为一名算法从业者，我几乎每天都在和各种版本的 YOLO 打交道：调参、部署、优化。但在高强度的工作节奏下，我发现自己陷入了一个**“熟练的陌生人”**误区：\n\n对抗遗忘： 算法的演进非常细碎。从 Anchor-based 到 Anchor-free，从简单的 IoU 到复杂的 $CIoU$、$DIoU$ 损失函数，如果不系统整理，很多细节（如正负样本匹配策略的改变）很容易在脑海中变得模糊。\n构建底层逻辑： 仅仅跑通 train.py 是远远不够的。为了在面试中对答如流，也为了在实际业务中能根据场景选择最合适的版本，我需要从底层原理出发，理解每一代 YOLO “为什么要这么改”。\n职业背书： 博客是最好的技术名片。通过深度解析，我希望向同行和面试官展示：我不仅能通过工具解决问题，更能洞察算法背后的设计哲学。\n\n\n1. 核心目标：整理、理解、内化这个系列不仅仅是论文的翻译，更是我个人的复习笔记和实战心得。我将重点攻克以下“硬骨头”：\n🔍 深度拆解每一代演进我会详细说明每个版本的改进原理，包括但不限于：\n\n网络架构 (Backbone, Neck, Head)： 每一代在特征提取和融合上做了哪些“加减法”？\n损失函数 (Loss Function)： 为什么分类损失和回归损失在不断迭代？\n匹配策略 (Label Assignment)： 详解从 Max IoU 到 SimOTA，再到 Task-Aligned Assigner 的逻辑跃迁。\n工程 Trick： 数据增强 (Mosaic)、重参数化 (RepVGG)、解耦头等技术的实际意义。\n\n📊 建立纵向知识地图我会复现并横向对比不同版本的性能指标，分析它们在 精度 ($mAP$) 与 速度 ($FPS$) 之间的权衡方案。\n\n2. 学习路线图 (Roadmap)为了方便复习，我将按以下节奏进行更新：\n\n\n\n阶段\n涵盖版本\n核心复习点\n\n\n\n第一阶段：奠基\nYOLOv1 - v3\n单阶段检测框架、Grid Cell 概念、Anchor 与 Darknet 架构\n\n\n第二阶段：巅峰工程\nYOLOv4 - v5\n数据增强 (Mosaic)、SPP&#x2F;PAN 结构、工程化的极致优化\n\n\n第三阶段：现代变革\nYOLOv6 - v8\nAnchor-free 时代、解耦头 (Decoupled Head)、动态匹配策略\n\n\n第四阶段：前沿探索\nYOLOv9 - v11\n可编程梯度信息 (PGI)、无 NMS 设计、效率与精度的极限\n\n\n\n3. 写在最后\n“Paper is cheap, show me the logic.”\n\n这个系列是我个人对目标检测领域的一次深度致敬。如果你也和我一样，经常在各个 YOLO 版本间“反复横跳”却抓不住重点，希望我的这些记录能陪你一起理清思路。\n这不仅是一份应聘时的展示作品，更是一份属于我自己的技术资产。\n\n下一篇预告：《YOLOv1：将检测视为回归的极简美学》—— 聊聊那个一切开始的地方。\n","categories":["YOLO系列"],"tags":["YOLO","目标检测","深度学习"]}]